{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Channel is a bidirectional stream that implements the io.ReadWriteCloser interface."}, {"role": "assistant", "content": "type Channel struct {\n\tbuffer *bytes.Buffer\n\tclosed bool\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewChannel creates a new in-memory Channel."}, {"role": "assistant", "content": "func NewChannel() *Channel {\n\treturn &Channel{\n\t\tbuffer: new(bytes.Buffer),\n\t}\n}\n\n/*\nRead reads data from the Channel's buffer.\n*/\nfunc (ch *Channel) Read(p []byte) (n int, err error) {\n\tif ch.closed && ch.buffer.Len() == 0 {\n\t\treturn 0, io.EOF\n\t}\n\treturn ch.buffer.Read(p)\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Pipe is a bidirectional stream that allows multiple channels (origins and destinations).\nIt routes data between multiple io.ReadWriteCloser interfaces and supports context for cancellation."}, {"role": "assistant", "content": "type Pipe struct {\n\tmu       sync.Mutex\n\tchannels []io.ReadWriteCloser\n\terrChan  chan error\n\tctx      context.Context\n\tcancel   context.CancelFunc\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewPipe creates a new Pipe with optional io.ReadWriteCloser channels and a context for cancellation or timeout."}, {"role": "assistant", "content": "func NewPipe(ctx context.Context, channels ...io.ReadWriteCloser) *Pipe {\n\tpipeCtx, cancel := context.WithCancel(ctx)\n\n\tpipe := &Pipe{\n\t\tchannels: channels,\n\t\terrChan:  make(chan error, len(channels)),\n\t\tctx:      pipeCtx,\n\t\tcancel:   cancel,\n\t}\n\n\t// Start a goroutine to handle data routing between channels\n\tgo pipe.routeData()\n\n\treturn pipe\n}\n\n/*\nrouteData starts the routing of data between the channels.\nEach channel has its own goroutine for reading and writing data.\nThe function listens to the context for cancellation or timeout.\n*/\nfunc (pipe *Pipe) routeData() {\n\tvar wg sync.WaitGroup\n\n\tfor _, ch := range pipe.channels {\n\t\twg.Add(1)\n\t\tgo func(ch io.ReadWriteCloser) {\n\t\t\tdefer wg.Done()\n\t\t\tpipe.handleChannel(ch)\n\t\t}(ch)\n\t}\n\n\t// Wait for all routines to complete, or for the context to be canceled\n\twg.Wait()\n\tclose(pipe.errChan)\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Builder is a wrapper around the Docker client that provides methods for building\nand running containers. It encapsulates the complexity of Docker operations,\nallowing for easier management of containerized environments."}, {"role": "assistant", "content": "type Builder struct {\n\tclient *client.Client\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewBuilder creates a new Builder instance.\nIt initializes a Docker client using the host's Docker environment settings."}, {"role": "assistant", "content": "func NewBuilder() (*Builder, error) {\n\tcli, err := client.NewClientWithOpts(client.FromEnv)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Builder{client: cli}, nil\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Runner encapsulates the functionality for running and interacting with Docker containers.\nIt provides methods to create, start, and attach to containers, allowing for seamless\nintegration with external systems such as language models."}, {"role": "assistant", "content": "type Runner struct {\n\tclient      *client.Client\n\tcontainerID string\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewRunner initializes a new Runner instance with a Docker client.\nThis setup allows for interaction with the Docker daemon on the host system."}, {"role": "assistant", "content": "func NewRunner() (*Runner, error) {\n\tcli, err := client.NewClientWithOpts(client.FromEnv)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Runner{client: cli}, nil\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "HTTPS wraps the Fiber app and sets up the middleware. It also contains the mapping\nto internal service endpoints."}, {"role": "assistant", "content": "type HTTPS struct {\n\tapp         *fiber.App\n\tslackEvents *comms.Events\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewHTTPS creates a new HTTPS service, configures the mapping to internal service endpoints\nfrom the config file, and sets up fiber (v3) to serve TLS requests."}, {"role": "assistant", "content": "func NewHTTPS() *HTTPS {\n\t// Initialize the architecture\n\treturn &HTTPS{\n\t\tapp: fiber.New(fiber.Config{\n\t\t\tCaseSensitive: true,\n\t\t\tStrictRouting: true,\n\t\t\tServerHeader:  \"Fiber\",\n\t\t\tAppName:       \"AMSH Service\",\n\t\t\tJSONEncoder:   json.Marshal,\n\t\t\tJSONDecoder:   json.Unmarshal,\n\t\t}),\n\t\tslackEvents: comms.NewEvents(),\n\t}\n}\n\n/*\nUp adds the middleware and starts the HTTPS service.\n*/\nfunc (https *HTTPS) Up() error {\n\thttps.app.Use(\n\t\tcors.New(cors.Config{\n\t\t\tAllowOrigins: []string{\"*\"},\n\t\t\tAllowHeaders: []string{\"*\"},\n\t\t\tAllowMethods: []string{\"*\"},\n\t\t}),\n\t\tfavicon.New(),\n\t)\n\n\t// WebSocket route using adaptor\n\thttps.app.Get(\"/ws\", adaptor.HTTPHandler(handler(https.websocketHandler)))\n\n\thttps.app.Post(\"/webhook/trengo\", https.NewWebhook(\"trengo\", \"managing\"))\n\thttps.app.Post(\"/webhook/github\", https.NewWebhook(\"github\", \"managing\"))\n\thttps.app.Post(\"/events/slack\", https.slackEvents.Run)\n\thttps.app.Use(\"/\", static.New(\"./frontend\"))\n\n\t// Start the main HTTP server\n\treturn https.app.Listen(\":8567\", fiber.ListenConfig{EnablePrefork: false})\n}\n\n/*\nShutdown gracefully shuts down the HTTPS service.\n*/\nfunc (https *HTTPS) Shutdown() error {\n\t// Shutdown the main HTTP server\n\tif err := https.app.Shutdown(); err != nil {\n\t\treturn err\n\t}\n\n\t// Add any necessary cleanup for the Slack events server\n\t// For now, we don't have a specific shutdown method for it\n\n\treturn nil\n}\n\nfunc handler(f http.HandlerFunc) http.Handler {\n\treturn http.HandlerFunc(f)\n}\n\nfunc (https *HTTPS) websocketHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, _, _, err := ws.UpgradeHTTP(r, w)\n\tif err != nil {\n\t\terrnie.Error(err)\n\t\treturn\n\t}\n\n\terrnie.Debug(\"WebSocket connection established\")\n\n\tgo func() {\n\t\tdefer conn.Close()\n\n\t\tfor {\n\t\t\tmsg, _, err := wsutil.ReadClientData(conn)\n\t\t\tif err != nil {\n\t\t\t\terrnie.Error(err)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif strings.Contains(string(msg), \"ping\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Create a new message\n\t\t\tmessage := data.New(utils.NewName(), \"task\", \"managing\", msg)\n\t\t\tmessage.Poke(\"chain\", \"websocket\")\n\t\t}\n\t}()\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Highlighter uses tree-sitter to parse and highlight code for multiple languages.\nWe chose tree-sitter because it provides a fast and accurate way to parse code\nand generate an Abstract Syntax Tree (AST), which is crucial for precise syntax highlighting.\nThis generic parser allows for easy extension to support multiple languages."}, {"role": "assistant", "content": "type Highlighter struct {\n\tstyles   *ui.Styles\n\thandle   *sitter.Parser\n\tlanguage *sitter.Language\n\tcode     string\n\ttree     *sitter.Tree\n\text      string\n\terr      error\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewHighlighter creates a new Highlighter instance for the specified language.\nWe initialize the parser here but don't parse the code immediately,\nallowing for more flexibility in when the parsing occurs."}, {"role": "assistant", "content": "func NewHighlighter(code, ext string) *Highlighter {\n\treturn &Highlighter{\n\t\tstyles: ui.NewStyles(),\n\t\thandle: sitter.NewParser(),\n\t\tcode:   code,\n\t\text:    ext,\n\t}\n}\n\n/*\nExtToLang returns the appropriate tree-sitter language based on the input string.\nThis function allows easy addition of new languages as they become supported.\n*/\nfunc (highlighter *Highlighter) ExtToLang(lang string) (*sitter.Language, error) {\n\tswitch lang {\n\tcase \"go\":\n\t\treturn golang.GetLanguage(), nil\n\tcase \"js\":\n\t\treturn javascript.GetLanguage(), nil\n\tcase \"py\":\n\t\treturn python.GetLanguage(), nil\n\tcase \"c\":\n\t\treturn c.GetLanguage(), nil\n\tcase \"cpp\":\n\t\treturn cpp.GetLanguage(), nil\n\tcase \"sh\":\n\t\treturn bash.GetLanguage(), nil\n\tcase \"rb\":\n\t\treturn ruby.GetLanguage(), nil\n\tcase \"rs\":\n\t\treturn rust.GetLanguage(), nil\n\tcase \"java\":\n\t\treturn java.GetLanguage(), nil\n\tcase \"ts\":\n\t\treturn typescript.GetLanguage(), nil\n\tcase \"tsx\":\n\t\treturn tsx.GetLanguage(), nil\n\tcase \"php\":\n\t\treturn php.GetLanguage(), nil\n\tcase \"cs\":\n\t\treturn csharp.GetLanguage(), nil\n\tcase \"css\":\n\t\treturn css.GetLanguage(), nil\n\tcase \"dockerfile\":\n\t\treturn dockerfile.GetLanguage(), nil\n\tcase \"ex\", \"exs\":\n\t\treturn elixir.GetLanguage(), nil\n\tcase \"elm\":\n\t\treturn elm.GetLanguage(), nil\n\tcase \"hcl\":\n\t\treturn hcl.GetLanguage(), nil\n\tcase \"html\":\n\t\treturn html.GetLanguage(), nil\n\tcase \"kt\":\n\t\treturn kotlin.GetLanguage(), nil\n\tcase \"lua\":\n\t\treturn lua.GetLanguage(), nil\n\tcase \"ml\", \"mli\":\n\t\treturn ocaml.GetLanguage(), nil\n\tcase \"scala\":\n\t\treturn scala.GetLanguage(), nil\n\tcase \"sql\":\n\t\treturn sql.GetLanguage(), nil\n\tcase \"swift\":\n\t\treturn swift.GetLanguage(), nil\n\tcase \"toml\":\n\t\treturn toml.GetLanguage(), nil\n\tcase \"yaml\", \"yml\":\n\t\treturn yaml.GetLanguage(), nil\n\tcase \"cue\":\n\t\treturn cue.GetLanguage(), nil\n\tcase \"groovy\":\n\t\treturn groovy.GetLanguage(), nil\n\tcase \"md\", \"markdown\":\n\t\treturn tree_sitter_markdown.GetLanguage(), nil\n\tcase \"protobuf\":\n\t\treturn protobuf.GetLanguage(), nil\n\tcase \"svelte\":\n\t\treturn svelte.GetLanguage(), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported language: %s\", lang)\n\t}\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "BoxStyle represents different styles for the box logger.\n\ntype BoxStyle string\n\nvar Dark = lipgloss.NewStyle().TabWidth(2).Foreground(lipgloss.Color(\"#666666\")).Render\nvar Muted = lipgloss.NewStyle().TabWidth(2).Foreground(lipgloss.Color(\"#999999\")).Render\nvar Highlight = lipgloss.NewStyle().TabWidth(2).Foreground(lipgloss.Color(\"#EEEEEE\")).Render\nvar Blue = lipgloss.NewStyle().TabWidth(2).Foreground(lipgloss.Color(\"#6E95F7\")).Render\nvar Red = lipgloss.NewStyle().TabWidth(2).Foreground(lipgloss.Color(\"#F7746D\")).Render\nvar Yellow = lipgloss.NewStyle().TabWidth(2).Foreground(lipgloss.Color(\"#F7B96D\")).Render\nvar Green = lipgloss.NewStyle().TabWidth(2).Foreground(lipgloss.Color(\"#06C26F\")).Render\nvar Purple = lipgloss.NewStyle().TabWidth(2).Foreground(lipgloss.Color(\"#6C50FF\")).Render\n\nconst (\n\tAIStyle      BoxStyle = \"ai\"\n\tSuccessStyle BoxStyle = \"success\"\n\tInfoStyle    BoxStyle = \"info\"\n\tWarningStyle BoxStyle = \"warning\"\n\tErrorStyle   BoxStyle = \"error\"\n)\n\n\nHeaderAlignment defines the place of the header label in the\ntop part of the box.\n\ntype HeaderAlignment string\n\nconst (\n\tHeaderLeft   HeaderAlignment = \"left\"\n\tHeaderRight  HeaderAlignment = \"right\"\n\tHeaderCenter HeaderAlignment = \"center\"\n)\n\n\nBoxLogger is a highly segmented way to log messages. It is both\noptimized for human readability and machine readability."}, {"role": "assistant", "content": "type BoxLogger struct {\n\tHeaderAlignment HeaderAlignment\n\tWidth           int\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewBoxLogger initializes a new BoxLogger with default settings."}, {"role": "assistant", "content": "func NewBoxLogger() *BoxLogger {\n\treturn &BoxLogger{\n\t\tHeaderAlignment: HeaderLeft,\n\t\tWidth:           80,\n\t}\n}\n\nfunc WithSpinner(task func(), msg string) {\n\t// Create a spinner configuration\n\tspinnerConfig := yacspin.Config{\n\t\tFrequency:       100 * time.Millisecond,\n\t\tCharSet:         yacspin.CharSets[59],\n\t\tSuffix:          \" \",\n\t\tSuffixAutoColon: true,\n\t\tMessage:         msg,\n\t\tStopCharacter:   \"\u2713\",\n\t\tStopColors:      []string{\"fgGreen\"},\n\t}\n\n\t// Initialize the spinner\n\tspinner, err := yacspin.New(spinnerConfig)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating spinner:\", err)\n\t\treturn\n\t}\n\n\t// Start the spinner before executing the task\n\tspinner.Start()\n\n\t// Execute the given task\n\ttask()\n\n\t// Stop the spinner after the task is completed\n\tspinner.Stop()\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Success logs a message with the \"Success\" style"}, {"role": "assistant", "content": "func AI(title string, content any) {\n\tfmt.Println(bl.drawBox(title, AIStyle, content))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Success logs a message with the \"Success\" style"}, {"role": "assistant", "content": "func Success(title string, content any) {\n\tfmt.Println(bl.drawBox(title, SuccessStyle, content))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Info logs a message with the \"Info\" style"}, {"role": "assistant", "content": "func Info(title string, content any) {\n\tfmt.Println(bl.drawBox(title, InfoStyle, content))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Warning logs a message with the \"Warning\" style"}, {"role": "assistant", "content": "func Warning(title string, content any) {\n\tfmt.Println(bl.drawBox(title, WarningStyle, content))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Error logs an error with a stack trace and code preview"}, {"role": "assistant", "content": "func Error(title string, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tstackTrace, file, line := bl.captureStackTrace()\n\tcodeSnippet := bl.captureCodeSnippet(file, line, 5)\n\n\tcontent := map[string]any{\n\t\t\"Error\":        err.Error(),\n\t\t\"Stack Trace\":  stackTrace,\n\t\t\"Code Snippet\": codeSnippet,\n\t}\n\tfmt.Println(bl.drawBox(title, ErrorStyle, content))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Buffer is a simple buffer, that can be used to store messages.\n\n Buffer manages the conversation history and message handling\ntype Buffer struct {\n\tmessages []provider.Message\n}\n\n Message represents a conversation message\ntype Message struct {\n\tName    string `json:\"name\"`\n\tRole    string `json:\"role\"`\n\tContent string `json:\"content\"`\n}\n\n\nNewBuffer creates a new buffer."}, {"role": "assistant", "content": "func NewBuffer() *Buffer {\n\treturn &Buffer{\n\t\tmessages: make([]provider.Message, 0),\n\t}\n}\n\n// GetMessages returns all messages in the conversation\nfunc (b *Buffer) GetMessages() []provider.Message {\n\tmessages := make([]provider.Message, 0)\n\tmessages = append(messages, b.messages...)\n\n\treturn messages\n}\n\nfunc (b *Buffer) AddMessage(role, content string) *Buffer {\n\tb.messages = append(b.messages, provider.Message{Role: role, Content: content})\n\treturn b\n}\n\nfunc (b *Buffer) AddToolResult(name, result string) {\n\tb.messages = append(b.messages, provider.Message{\n\t\tRole:    \"tool\",\n\t\tContent: fmt.Sprintf(\"Tool %s returned: %s\", name, result),\n\t})\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Processor is a struct that manages the cores and channels for a distributed AI system."}, {"role": "assistant", "content": "type Processor struct {\n\tkey   string\n\tlayer *process.Layer\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewProcessor creates a new processor with the given key."}, {"role": "assistant", "content": "func NewProcessor(key string, layer *process.Layer) *Processor {\n\tlog.Info(\"NewProcessor\", \"key\", key)\n\n\treturn &Processor{\n\t\tkey:   key,\n\t\tlayer: layer,\n\t}\n}\n\n/*\nProcess processes the input string and returns a channel of results.\n*/\nfunc (processor *Processor) Process(input string) <-chan provider.Event {\n\tlog.Info(\"Processor.Process\", \"input\", input)\n\tout := make(chan provider.Event)\n\n\tgo func() {\n\t\tdefer close(out)\n\n\t\tfor _, process := range processor.layer.Processes {\n\t\t\tfor event := range NewCore(processor.key, process).Run(input) {\n\t\t\t\tout <- event\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn out\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewBalancedProvider creates a new BalancedProvider as an ambient context,\nso multiple calls to NewBalancedProvider will return the same instance."}, {"role": "assistant", "content": "func NewBalancedProvider() *BalancedProvider {\n\tonceBalancedProvider.Do(func() {\n\t\terrnie.Info(\"new balanced provider\")\n\n\t\tbalancedProviderInstance = &BalancedProvider{\n\t\t\tproviders: []*ProviderStatus{\n\t\t\t\t{\n\t\t\t\t\tname:     \"llama3.2:3b\",\n\t\t\t\t\tprovider: NewOllama(\"llama3.2:3b\"),\n\t\t\t\t\toccupied: false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname:     \"gpt-4o-mini\",\n\t\t\t\t\tprovider: NewOpenAI(os.Getenv(\"OPENAI_API_KEY\"), openai.ChatModelGPT4oMini2024_07_18),\n\t\t\t\t\toccupied: false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname:     \"claude-3-5-sonnet\",\n\t\t\t\t\tprovider: NewAnthropic(os.Getenv(\"ANTHROPIC_API_KEY\"), anthropic.ModelClaude3_5Sonnet20241022),\n\t\t\t\t\toccupied: false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname:     \"gemini-1.5-flash\",\n\t\t\t\t\tprovider: NewGoogle(os.Getenv(\"GEMINI_API_KEY\"), \"gemini-1.5-flash\"),\n\t\t\t\t\toccupied: false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname:     \"command-r\",\n\t\t\t\t\tprovider: NewCohere(os.Getenv(\"COHERE_API_KEY\"), \"command-r\"),\n\t\t\t\t\toccupied: false,\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tselectIndex: 0,\n\t\t}\n\t})\n\n\treturn balancedProviderInstance\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "TemporalDynamics represents the evolution of thoughts over time."}, {"role": "assistant", "content": "type TemporalDynamics struct {\n\tTimeline       []TimePoint     `json:\"timeline\" jsonschema:\"description:Sequence of thought states; required\"`\n\tCausalChains   []CausalChain   `json:\"causal_chains\" jsonschema:\"description:Cause-effect relationships over time; required\"`\n\tEvolutionRules []EvolutionRule `json:\"evolution_rules\" jsonschema:\"description:Patterns of state change; required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "TensorNetwork represents multi-dimensional relationships and patterns."}, {"role": "assistant", "content": "type TensorNetwork struct {\n\tDimensions   []Dimension   `json:\"dimensions\" jsonschema:\"description:Different aspects of relationship space,required\"`\n\tTensorFields []TensorField `json:\"tensor_fields\" jsonschema:\"description:Multi-dimensional relationship patterns,required\"`\n\tProjections  []Projection  `json:\"projections\" jsonschema:\"description:Lower-dimensional views of the tensor space,required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "HypergraphLayer represents relationships between multiple nodes simultaneously."}, {"role": "assistant", "content": "type HypergraphLayer struct {\n\tNodes      []HyperNode   `json:\"nodes\" jsonschema:\"description:Nodes in the hypergraph; required\"`\n\tHyperEdges []HyperEdge   `json:\"hyper_edges\" jsonschema:\"description:Edges connecting multiple nodes; required\"`\n\tClusters   []NodeCluster `json:\"clusters\" jsonschema:\"description:Emergent groupings of nodes; required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "FractalStructure represents self-similar patterns at different scales."}, {"role": "assistant", "content": "type FractalStructure struct {\n\tBasePattern    Pattern `json:\"base_pattern\" jsonschema:\"description:Fundamental pattern that repeats; required\"`\n\tScales         []Scale `json:\"scales\" jsonschema:\"description:Different levels of pattern manifestation; required\"`\n\tIterations     int     `json:\"iterations\" jsonschema:\"description:Depth of fractal recursion; required\"`\n\tSelfSimilarity float64 `json:\"self_similarity\" jsonschema:\"description:Degree of pattern preservation across scales; required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "CrossLayerSynthesis represents integration across different representation layers."}, {"role": "assistant", "content": "type CrossLayerSynthesis struct {\n\tMappings     []LayerMapping `json:\"mappings\" jsonschema:\"description:Correspondences between layers,required\"`\n\tIntegrations []Integration  `json:\"integrations\" jsonschema:\"description:Unified patterns across layers,required\"`\n\tConflicts    []Conflict     `json:\"conflicts\" jsonschema:\"description:Contradictions between layers,required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "HolographicMemory represents distributed information storage."}, {"role": "assistant", "content": "type HolographicMemory struct {\n\tEncodings          []Encoding        `json:\"encodings\" jsonschema:\"description:Distributed information patterns; required\"`\n\tInterferenceSpace  InterferenceSpace `json:\"interference_space\" jsonschema:\"description:Interaction between encodings; required\"`\n\tReconstructionKeys []string          `json:\"reconstruction_keys\" jsonschema:\"description:Access patterns for information retrieval; required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "CompositeProcess is a Process that is a composition of other Processes."}, {"role": "assistant", "content": "type CompositeProcess struct {\n\tLayers []*Layer `json:\"layers\" jsonschema:\"title:Layers,description:The layers of the composite process,enum:task_analysis,trengo,pull_request,abstract,bridge,ideate,required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "CompositeProcessMap is a map of CompositeProcesses by key.\n\nvar CompositeProcessMap = map[string]*CompositeProcess{\n\t\"task_analysis\": {Layers: []*Layer{LayerMap[\"task_analysis\"]}},\n\t\"trengo\":        {Layers: []*Layer{LayerMap[\"trengo\"]}},\n\t\"pull_request\":  {Layers: []*Layer{LayerMap[\"pull_request\"]}},\n}\n\n\nLayer is a collection of Processes that are related to each other in a way\nthat allows their results to be combined in a meaningful way, and serve as\nthe input for the next layer, and can be run in parallel."}, {"role": "assistant", "content": "type Layer struct {\n\tProcesses []Process `json:\"processes\" jsonschema:\"title:Processes,description:The processes of the layer,enum:breakdown,planning,discussion,layering,required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NarrativeAnalysis transforms abstract patterns into coherent storylines."}, {"role": "assistant", "content": "type NarrativeAnalysis struct {\n\tStoryElements []StoryElement `json:\"story_elements\" jsonschema:\"required,description:Building blocks of the narrative\"`\n\tStoryFlow     StoryFlow      `json:\"story_flow\" jsonschema:\"required,description:Narrative progression and connections\"`\n\tThemeMapping  ThemeMapping   `json:\"theme_mapping\" jsonschema:\"required,description:Abstract concepts mapped to narrative elements\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "AnalogyAnalysis creates relatable comparisons for abstract concepts."}, {"role": "assistant", "content": "type AnalogyAnalysis struct {\n\tAnalogies     []Analogy      `json:\"analogies\" jsonschema:\"required,description:Set of analogies for abstract concepts\"`\n\tMappings      []AnalogyMap   `json:\"mappings\" jsonschema:\"required,description:How abstract concepts map to familiar ideas\"`\n\tRelationships []Relationship `json:\"relationships\" jsonschema:\"required,description:How analogies relate to each other\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "PracticalAnalysis converts abstract insights into actionable steps."}, {"role": "assistant", "content": "type PracticalAnalysis struct {\n\tActions        []Action       `json:\"actions\" jsonschema:\"required,description:Concrete actions derived from abstract insights\"`\n\tDependencies   []Dependency   `json:\"dependencies\" jsonschema:\"required,description:Relationships between actions\"`\n\tImplementation Implementation `json:\"implementation\" jsonschema:\"required,description:How to implement the actions\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "ContextAnalysis grounds abstract insights in user's specific situation."}, {"role": "assistant", "content": "type ContextAnalysis struct {\n\tRelevance       []RelevanceMap   `json:\"relevance\" jsonschema:\"required,description:How insights apply to context\"`\n\tConstraints     []Constraint     `json:\"constraints\" jsonschema:\"required,description:Contextual limitations\"`\n\tOpportunities   []Opportunity    `json:\"opportunities\" jsonschema:\"required,description:Context-specific possibilities\"`\n\tRecommendations []Recommendation `json:\"recommendations\" jsonschema:\"required,description:Context-aware suggestions\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "EmergentPatterns represents higher-order patterns that emerge from interactions."}, {"role": "assistant", "content": "type EmergentPatterns struct {\n\tPatterns         []Pattern         `json:\"patterns\" jsonschema:\"description:Discovered higher-order patterns; required\"`\n\tEmergenceRules   []EmergenceRule   `json:\"emergence_rules\" jsonschema:\"description:Rules governing pattern formation; required\"`\n\tStabilityMetrics []StabilityMetric `json:\"stability_metrics\" jsonschema:\"description:Measures of pattern stability; required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "UnifiedPerspective represents a coherent view across all structures."}, {"role": "assistant", "content": "type UnifiedPerspective struct {\n\tGlobalPatterns []GlobalPattern  `json:\"global_patterns\" jsonschema:\"required,description:Patterns visible across all layers\"`\n\tCoherence      float64          `json:\"coherence\" jsonschema:\"required,description:Measure of overall integration\"`\n\tInsights       []UnifiedInsight `json:\"insights\" jsonschema:\"required,description:Understanding derived from the whole\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Discussion is a process where multiple AI agents discuss a topic and come to a\nconsensus, which will be the final response of the process."}, {"role": "assistant", "content": "type Discussion struct {\n\tTopic       string `json:\"topic\" jsonschema:\"title=Topic,description=The topic to discuss,required\"`\n\tNextSpeaker string `json:\"next_speaker\" jsonschema:\"title=Next Speaker,description=The name of the next speaker,required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Thinking is a process that allows the system to think about a given topic.\nIt now includes a detailed reasoning graph to capture multi-level and interconnected reasoning steps."}, {"role": "assistant", "content": "type Thinking struct {\n\tHypergraphLayer     HypergraphLayer     `json:\"hypergraph_layer\" jsonschema:\"description:Represents many-to-many relationships and group dynamics,required\"`\n\tTensorNetwork       TensorNetwork       `json:\"tensor_network\" jsonschema:\"description:Multi-dimensional relationship patterns,required\"`\n\tFractalStructure    FractalStructure    `json:\"fractal_structure\" jsonschema:\"description:Self-similar patterns at different scales,required\"`\n\tQuantumLayer        QuantumLayer        `json:\"quantum_layer\" jsonschema:\"description:Probabilistic and superposition states,required\"`\n\tHolographicMemory   HolographicMemory   `json:\"holographic_memory\" jsonschema:\"description:Distributed information storage,required\"`\n\tTemporalDynamics    TemporalDynamics    `json:\"temporal_dynamics\" jsonschema:\"description:Time-based evolution of thoughts,required\"`\n\tEmergentPatterns    EmergentPatterns    `json:\"emergent_patterns\" jsonschema:\"description:Higher-order patterns that emerge from interactions,required\"`\n\tCrossLayerSynthesis CrossLayerSynthesis `json:\"cross_layer_synthesis\" jsonschema:\"description:Integration across different representation layers,required\"`\n\tUnifiedPerspective  UnifiedPerspective  `json:\"unified_perspective\" jsonschema:\"description:Coherent view across all structures,required\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "QuantumLayer represents probabilistic and superposition states of thoughts."}, {"role": "assistant", "content": "type QuantumLayer struct {\n\tSuperpositionStates []SuperpositionState `json:\"superposition_states\" jsonschema:\"required,description:Multiple simultaneous possibilities\"`\n\tEntanglements       []Entanglement       `json:\"entanglements\" jsonschema:\"required,description:Correlated state relationships\"`\n\tWaveFunction        WaveFunction         `json:\"wave_function\" jsonschema:\"required,description:Probability distribution of states\"`\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "createCollectionIfNotExists uses an HTTP PUT call to create a collection if it does not exist."}, {"role": "assistant", "content": "func createCollectionIfNotExists(collection string, uri *url.URL, dimension uint64) error {\n\tvar (\n\t\tresponse *client.Response\n\t\terr      error\n\t)\n\n\t// First we do a GET call to check if the collection exists\n\tif response, err = client.Get(uri.String() + \"/collections/\" + collection); errnie.Error(err) != nil {\n\t\treturn errnie.Error(err)\n\t}\n\n\tif response.StatusCode() == 404 {\n\t\t// Prepare the request body for creating a new collection\n\t\trequestBody := map[string]interface{}{\n\t\t\t\"name\": collection,\n\t\t\t\"vectors\": map[string]interface{}{\n\t\t\t\t\"size\":     dimension,\n\t\t\t\t\"distance\": \"Cosine\",\n\t\t\t},\n\t\t}\n\n\t\tresponse = errnie.SafeMust(func() (*client.Response, error) {\n\t\t\treturn client.Put(uri.String()+\"/collections/\"+collection, client.Config{\n\t\t\t\tHeader: map[string]string{\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t},\n\t\t\t\tBody: requestBody,\n\t\t\t})\n\t\t})\n\t}\n\n\terrnie.Debug(response.String())\n\n\treturn nil\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Queue is a simple pub/sub implementation that allows for topics to be created\non the fly and for subscribers to be added and removed dynamically."}, {"role": "assistant", "content": "type Queue struct {\n\tctx    context.Context\n\tcancel context.CancelFunc\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewQueue instantiates a new queue, creating a context and cancel function\nthat can be used to signal the queue to stop processing new jobs.\nIt is an ambient context, so multiple calls to this function will return\nthe same instance."}, {"role": "assistant", "content": "func NewQueue() *Queue {\n\tonceQueue.Do(func() {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tqueueInstance = &Queue{\n\t\t\tctx:    ctx,\n\t\t\tcancel: cancel,\n\t\t}\n\t})\n\n\treturn queueInstance\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Employer is an interface that can be implemented by objects that want\nto be able to be scheduled onto a worker pool.\n\ntype Employer interface {\n\tio.ReadWriter\n\tPoolSize() int\n}\n\n\nPool is a set of Worker types, each running their own (pre-warmed) goroutine.\nAny object that implements the Job interface is able to schedule work on the\nworker pool, which keeps the amount of goroutines in check, while still being\nable to benefit from high concurrency in all kinds of scenarios."}, {"role": "assistant", "content": "type Pool struct {\n\tctx     context.Context\n\tcancel  context.CancelFunc\n\tworkers chan chan Job\n\tjobs    chan Job\n\thandles []PoolWorker\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewPool instantiates a worker pool with bound size of maxWorkers, taking in a\nContext type to be able to cleanly cancel all of the sub processes it starts."}, {"role": "assistant", "content": "func NewPool() *Pool {\n\toncePool.Do(func() {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tpoolInstance = &Pool{\n\t\t\tctx:     ctx,\n\t\t\tcancel:  cancel,\n\t\t\tworkers: make(chan chan Job),\n\t\t\tjobs:    make(chan Job),\n\t\t\thandles: make([]PoolWorker, 0),\n\t\t}\n\t\tpoolInstance.Run()\n\t})\n\n\treturn poolInstance\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Scaler controls the size of a worker pool and dynamically scales the\namount of worker routines, based on the current workload. This allows\nus to redirect system resources to other pools when the load is low,\nor allocate more resources when the load is high."}, {"role": "assistant", "content": "type Scaler struct {\n\tinterval time.Duration\n\trate     int\n\tstats    int64\n\tperiod   int\n\tlevel    int\n\tsamples  int\n\toverload bool\n\tlower    bool\n\tpool     *Pool\n\tmaxIdle  time.Duration\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewScaler constructs a scaler which controls the size of a\nworker pool dynamically, based on the consumption of\nmachine resources."}, {"role": "assistant", "content": "func NewScaler(pool *Pool) *Scaler {\n\treturn &Scaler{\n\t\tinterval: 100,\n\t\trate:     10,\n\t\tstats:    0,\n\t\tperiod:   0,\n\t\tlevel:    1,\n\t\tsamples:  3,\n\t\toverload: false,\n\t\tlower:    false,\n\t\tpool:     pool,\n\t\tmaxIdle:  1 * time.Second,\n\t}\n}\n\nfunc (scaler *Scaler) Run() {\n\t// Periodically  we will evaluate the performance of the worker\n\t// pool and potentially grow or shrink it.\n\tticker := time.NewTicker(scaler.interval * time.Millisecond)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-scaler.pool.ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tscaler.load()\n\n\t\t\t\t// Start growing the worker pool when it is not\n\t\t\t\t// overloaded and there are actually jobs in the queue.\n\t\t\t\tif !scaler.overload && len(scaler.pool.jobs) > 0 {\n\t\t\t\t\tscaler.Grow()\n\t\t\t\t}\n\n\t\t\t\t// Start shrinking the worker pool when overloaded.\n\t\t\t\tif scaler.overload {\n\t\t\t\t\tscaler.Shrink()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "New creates a new artifact with the given origin, role, scope, and data."}, {"role": "assistant", "content": "func New(origin, role, scope string, data []byte) *Artifact {\n\tvar (\n\t\tseg      *capnp.Segment\n\t\terr      error\n\t\tartifact Artifact\n\t)\n\n\tif _, seg, err = capnp.NewMessage(capnp.SingleSegment(nil)); err != nil {\n\t\treturn Empty()\n\t}\n\n\tif artifact, err = NewArtifact(seg); err != nil {\n\t\treturn Empty()\n\t}\n\n\tartifact.SetTimestamp(uint64(time.Now().UnixNano()))\n\tartifact.SetVersion(version)\n\tartifact.SetId(uuid.New().String())\n\n\t// Error handling: if setting any required field fails, return Empty()\n\tif err := artifact.SetOrigin(origin); err != nil {\n\t\terrnie.Error(err)\n\t\treturn Empty()\n\t}\n\tif err := artifact.SetRole(role); err != nil {\n\t\terrnie.Error(err)\n\t\treturn Empty()\n\t}\n\tif err := artifact.SetScope(scope); err != nil {\n\t\terrnie.Error(err)\n\t\treturn Empty()\n\t}\n\tif err := artifact.SetPayload(data); err != nil {\n\t\terrnie.Error(err)\n\t\treturn Empty()\n\t}\n\n\treturn &artifact\n}\n\n/*\nPeek retrieves a value from the artifact, starting by looking for an existing field,\nand falling back to searching the attribute list.\n*/\n// Peek returns (value, exists)\nfunc (artifact *Artifact) Peek(key string) string {\n\tvar (\n\t\tvalue string\n\t\tdata  []byte\n\t\terr   error\n\t)\n\n\t// Check if the key corresponds to a top-level field.\n\tswitch key {\n\tcase \"id\":\n\t\tvalue, err = artifact.Id()\n\tcase \"version\":\n\t\tvalue, err = artifact.Version()\n\tcase \"type\":\n\t\tvalue, err = artifact.Type()\n\tcase \"origin\":\n\t\tvalue, err = artifact.Origin()\n\tcase \"role\":\n\t\tvalue, err = artifact.Role()\n\tcase \"scope\":\n\t\tvalue, err = artifact.Scope()\n\tcase \"payload\":\n\t\tdata, err = artifact.Payload()\n\t\tvalue = string(data)\n\tdefault:\n\t\t// If the key is not a top-level field, look in the attributes list.\n\t\tvalue, err = artifact.getAttributeValue(key)\n\t}\n\n\tif err != nil {\n\t\terrnie.Error(err)\n\t\treturn err.Error()\n\t}\n\n\treturn value\n}\n\n// Poke sets a value and returns a boolean indicating success\nfunc (artifact *Artifact) Poke(key, value string) {\n\tvar err error\n\n\tswitch key {\n\tcase \"id\":\n\t\terr = artifact.SetId(value)\n\tcase \"version\":\n\t\terr = artifact.SetVersion(value)\n\tcase \"type\":\n\t\terr = artifact.SetType(value)\n\tcase \"origin\":\n\t\terr = artifact.SetOrigin(value)\n\tcase \"role\":\n\t\terr = artifact.SetRole(value)\n\tcase \"scope\":\n\t\terr = artifact.SetScope(value)\n\tcase \"payload\":\n\t\terr = artifact.SetPayload([]byte(value))\n\tdefault:\n\t\t// Check if the attribute already exists and update it, or add a new one\n\t\terr = artifact.updateOrAddAttribute(key, value)\n\t}\n\n\tif err != nil {\n\t\terrnie.Error(err)\n\t}\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Generator is used to construct the splash screen that is displayed when the shell is started.\nIt implements the io.Reader interface to allow it to be used in the render pipeline."}, {"role": "assistant", "content": "type Generator struct {\n\tcontent *bytes.Buffer\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "NewGenerator creates a new Generator with the content of the logo."}, {"role": "assistant", "content": "func NewGenerator() *Generator {\n\treturn &Generator{\n\t\tcontent: bytes.NewBufferString(content),\n\t}\n}\n\n/*\nRead reads the content of the logo into the provided buffer.\n*/\nfunc (generator *Generator) Read(p []byte) (n int, err error) {\n\treturn generator.content.Read(p)\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Initialize logging system by configuring log styles, setting log levels,\nand initializing log files if applicable."}, {"role": "assistant", "content": "func init() {\n\t// Initialize the log file\n\tinitLogFile()\n\tif logFile == nil {\n\t\tfmt.Println(\"WARNING: Log file initialization failed!\")\n\t}\n\n\t// Set log level based on configuration\n\tsetLogLevel()\n\n\t// Periodic routine to print the number of active goroutines\n\t// go func() {\n\t// \tfor range time.Tick(time.Second * 5) {\n\t// \t\tlogger.Debug(\"active goroutines\", \"count\", runtime.NumGoroutine())\n\t// \t}\n\t// }()\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Set the appropriate logging level from Viper configuration."}, {"role": "assistant", "content": "func setLogLevel() {\n\tswitch viper.GetString(\"loglevel\") {\n\tcase \"trace\", \"debug\":\n\t\tlogger.SetLevel(log.DebugLevel)\n\tcase \"info\":\n\t\tlogger.SetLevel(log.InfoLevel)\n\tcase \"warn\":\n\t\tlogger.SetLevel(log.WarnLevel)\n\tcase \"error\":\n\t\tlogger.SetLevel(log.ErrorLevel)\n\tdefault:\n\t\tlogger.SetLevel(log.DebugLevel)\n\t}\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Initialize the log file by creating or overwriting the log file.\nHandles any errors during initialization gracefully."}, {"role": "assistant", "content": "func initLogFile() {\n\tlogDir := \"./\"\n\tif err := os.MkdirAll(logDir, 0755); err != nil {\n\t\tfmt.Printf(\"Failed to create log directory: %v\\n\", err)\n\t\treturn\n\t}\n\n\tlogFilePath := filepath.Join(logDir, \"amsh.log\")\n\tvar err error\n\tlogFile, err = os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to open log file: %v\\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Log file successfully initialized: %s\\n\", logFilePath)\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Log a formatted message to the standard logger as well as to the log file."}, {"role": "assistant", "content": "func Log(format string, v ...interface{}) {\n\tmessage := fmt.Sprintf(format, v...)\n\tif message == \"\" {\n\t\treturn\n\t}\n\twriteToLog(message)\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Raw is a full decomposition of the object passed in."}, {"role": "assistant", "content": "func Raw(v ...interface{}) {\n\tspew.Dump(v...)\n\twriteToLog(spew.Sprint(v...))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Trace logs a trace message to the logger."}, {"role": "assistant", "content": "func Trace(v ...interface{}) {\n\tlogger.Debug(v[0], v[1:]...)\n\twriteToLog(fmt.Sprintf(\"%v\", v))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Debug logs a debug message to the logger."}, {"role": "assistant", "content": "func Debug(format string, v ...interface{}) {\n\tlogger.Debug(fmt.Sprintf(format, v...))\n\twriteToLog(fmt.Sprintf(format, v...))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Note is a custom log message with a different style."}, {"role": "assistant", "content": "func Note(format string, v ...interface{}) {\n\tlogger.Info(fmt.Sprintf(format, v...))\n\twriteToLog(fmt.Sprintf(format, v...))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Success is a custom log message with a different style."}, {"role": "assistant", "content": "func Success(format string, v ...interface{}) {\n\tlogger.Info(fmt.Sprintf(format, v...))\n\twriteToLog(fmt.Sprintf(format, v...))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Info logs an info message to the logger."}, {"role": "assistant", "content": "func Info(format string, v ...interface{}) {\n\tlogger.Info(fmt.Sprintf(format, v...))\n\twriteToLog(fmt.Sprintf(format, v...))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Warn logs a warn message to the logger."}, {"role": "assistant", "content": "func Warn(format string, v ...interface{}) {\n\tlogger.Warn(fmt.Sprintf(format, v...))\n\twriteToLog(fmt.Sprintf(format, v...))\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Error logs the error and returns it, useful for inline error logging and returning.\n\nExample usage:\n\n\terr := someFunction()\n\tif err != nil {\n\t\treturn Error(err, \"additional context\")\n\t}"}, {"role": "assistant", "content": "func Error(err error, v ...interface{}) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\tmessage := fmt.Sprintf(\"%s\\n%s\", err.Error(), getStackTrace())\n\tmessage += \"\\n\" + getCodeSnippet(err.Error(), 0, 10)\n\n\tlogger.Error(message, v...)\n\twriteToLog(message)\n\treturn err\n}\n\n/*\nWrite a log message to the log file, ensuring thread safety.\n*/\nfunc writeToLog(message string) {\n\tif message == \"\" || logFile == nil {\n\t\treturn\n\t}\n\n\tlogFileMu.Lock()\n\tdefer logFileMu.Unlock()\n\n\t// Strip ANSI escape codes and add a timestamp\n\tformattedMessage := fmt.Sprintf(\"[%s] %s\\n\", time.Now().Format(\"15:04:05\"), stripansi.Strip(strings.TrimSpace(message)))\n\n\t_, err := logFile.WriteString(formattedMessage)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to write to log file: %v\\n\", err)\n\t}\n\n\t// Ensure the write is flushed to disk\n\tif err := logFile.Sync(); err != nil {\n\t\tfmt.Printf(\"Failed to sync log file: %v\\n\", err)\n\t}\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Retrieve and format a stack trace from the current execution point."}, {"role": "assistant", "content": "func getStackTrace() string {\n\tconst depth = 32\n\tvar pcs [depth]uintptr\n\tn := runtime.Callers(3, pcs[:])\n\tframes := runtime.CallersFrames(pcs[:n])\n\n\tvar trace strings.Builder\n\tfor {\n\t\tframe, more := frames.Next()\n\t\tif !more {\n\t\t\tbreak\n\t\t}\n\n\t\tfuncName := frame.Function\n\t\tif lastSlash := strings.LastIndexByte(funcName, '/'); lastSlash >= 0 {\n\t\t\tfuncName = funcName[lastSlash+1:]\n\t\t}\n\t\tfuncName = strings.Replace(funcName, \".\", \":\", 1)\n\n\t\tline := fmt.Sprintf(\"%s at %s(line %d)\\n\",\n\t\t\tlipgloss.NewStyle().Foreground(lipgloss.Color(\"#6E95F7\")).Render(funcName),\n\t\t\tlipgloss.NewStyle().Foreground(lipgloss.Color(\"#06C26F\")).Render(filepath.Base(frame.File)),\n\t\t\tframe.Line,\n\t\t)\n\t\ttrace.WriteString(line)\n\t}\n\n\treturn \"\\n===[STACK TRACE]===\\n\" + trace.String() + \"===[/STACK TRACE]===\\n\"\n}\n\n/*\nRetrieve and return a code snippet surrounding the given line in the provided file.\n*/\nfunc getCodeSnippet(file string, line, radius int) string {\n\tfileHandle, err := os.Open(file)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tdefer fileHandle.Close()\n\n\tscanner := bufio.NewScanner(fileHandle)\n\tcurrentLine := 1\n\tvar snippet strings.Builder\n\n\tfor scanner.Scan() {\n\t\tif currentLine >= line-radius && currentLine <= line+radius {\n\t\t\tprefix := \"  \"\n\t\t\tif currentLine == line {\n\t\t\t\tprefix = \"> \"\n\t\t\t}\n\t\t\tsnippet.WriteString(fmt.Sprintf(\"%s%d: %s\\n\", prefix, currentLine, scanner.Text()))\n\t\t}\n\t\tcurrentLine++\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\"\n\t}\n\n\treturn snippet.String()\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "Must panics if an error is not nil. Otherwise, it returns the value.\n\nThis function is useful for simplifying error handling in scenarios where errors are not expected\nand should terminate the program if they occur. By panicking, it avoids the need for repetitive\nerror checks after every call.\n\nExample usage:\n\n\tvalue := Must(someFuncThatReturnsValueAndError())\n\tfmt.Println(value)  This will only execute if no error occurs.\n\nfunc Must[T any](value T, err error) T {\n\tif err != nil {\n\t\tError(err)\n\t\tpanic(err)\n\t}\n\treturn value\n}\n\n\nMustVoid is used when a function returns only an error, and we need to panic if it fails.\n\nThis is helpful for simplifying functions that do not return a value but may return an error.\nInstead of handling the error explicitly, MustVoid will panic if the error is non-nil.\n\nExample usage:\n\n\tMustVoid(someFuncThatReturnsOnlyError())"}, {"role": "assistant", "content": "func MustVoid(err error) {\n\tif err != nil {\n\t\tError(err)\n\t\tpanic(err)\n\t}\n}"}]}
{"messages": [{"role": "system", "content": "You are a Go developer who writes clear, readable, and idiomatic code."}, {"role": "user", "content": "SafeMust wraps a function call, and if there is a panic, it automatically recovers.\n\nThis function is used to safely execute a function that may return an error. If an error occurs,\nor if the function panics, SafeMust will recover and log the panic instead of crashing the program.\nThis can be useful for non-critical operations where you want the program to continue running.\n\nExample usage:\n\n\tresult := SafeMust(func() (int, error) {\n\t\treturn someComputation()\n\t})\n\tfmt.Println(result)\n\nfunc SafeMust[T any](fn func() (T, error)) T {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tLog(\"Recovered from panic in SafeMust: %v\", r)\n\t\t}\n\t}()\n\treturn Must(fn())\n}\n\n\nSafeMustVoid wraps a function call that returns an error and recovers from panics.\n\nIf the function provided to SafeMustVoid returns an error or panics, this function will\nrecover gracefully and log the error. This is particularly useful for functions that\nare expected to continue even if an error occurs, and should not crash the program.\n\nExample usage:\n\n\tSafeMustVoid(func() error {\n\t\treturn someNonCriticalOperation()\n\t})"}, {"role": "assistant", "content": "func SafeMustVoid(fn func() error) {\n\tif fn == nil {\n\t\tError(errors.New(\"SafeMustVoid called with nil function\"))\n\t\tpanic(\"SafeMustVoid called with nil function\")\n\t}\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tLog(\"Recovered from panic in SafeMustVoid: %v\", r)\n\t\t}\n\t}()\n\tMustVoid(fn())\n}"}]}
